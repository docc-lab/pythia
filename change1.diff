diff --git a/Cargo.lock b/Cargo.lock
index aa0c661..5102e60 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1,5 +1,25 @@
 # This file is automatically @generated by Cargo.
 # It is not intended for manual editing.
+[[package]]
+name = "GSL"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "723c72a7ebe8c502ec48cd13934b8edbba83cac0da443c173e0fc3ba329c09b0"
+dependencies = [
+ "GSL-sys",
+ "paste",
+]
+
+[[package]]
+name = "GSL-sys"
+version = "2.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ed0234c8208deaa95d9b8de380c89fb98059d87ead9045853f0961987717465"
+dependencies = [
+ "libc",
+ "pkg-config",
+]
+
 [[package]]
 name = "aho-corasick"
 version = "0.7.10"
@@ -1094,6 +1114,12 @@ dependencies = [
  "winapi 0.3.8",
 ]

+[[package]]
+name = "paste"
+version = "1.0.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c5d65c4d95931acda4498f675e332fcbdc9a06705cd07086c510e9b6009cd1c1"
+
 [[package]]
 name = "percent-encoding"
 version = "1.0.1"
@@ -1199,6 +1225,7 @@ dependencies = [
 name = "pythia"
 version = "0.1.0"
 dependencies = [
+ "GSL",
  "bimap",
  "byteorder",
  "chrono",
diff --git a/Cargo.toml b/Cargo.toml
index ee620a6..a625bab 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -17,6 +17,7 @@ petgraph = { version = "*", features = ["serde-1"] }
 clap = "*"
 hex = "*"
 rust-crypto = "*"
+GSL = "2.0"
 streaming-stats = "*"
 histogram = "0.6.9"
 lazy_static = "*"
@@ -35,4 +36,4 @@ itertools = "*"
 config = "*"
 threadpool = "*"
 [target.'cfg(target_os = "linux")'.dependencies]
-procinfo = "*"
\ No newline at end of file
+procinfo = "*"
diff --git a/src/grouping.rs b/src/grouping.rs
index a577ffe..cd9014c 100644
--- a/src/grouping.rs
+++ b/src/grouping.rs
@@ -1,10 +1,11 @@
 //! Code related to grouping critical paths
-
+extern crate rgsl;
 use std::collections::HashMap;
+use std::collections::HashSet;
 use std::fmt;
 use std::fmt::Display;
 use std::time::Duration;
-
+use std::mem;
 use petgraph::dot::Dot;
 use petgraph::graph::EdgeIndex;
 use petgraph::graph::NodeIndex;
@@ -22,6 +23,8 @@ use crate::trace::TraceNode;
 use crate::trace::TracepointID;
 use crate::trace::Value;

+use rgsl::statistics::correlation;
+
 use histogram::Histogram;

 /// A group of critical paths
@@ -36,10 +39,9 @@ pub struct Group {
     /// The raw critical paths that this group was constructed from
     pub traces: Vec<CriticalPath>,
     pub variance: f64,
-   // pub key_value_pairs: HashMap<String, Vec<Value>>,
+    pub key_value_pairs: HashMap<String, Vec<Value>>,
    // tsl: Group means to calculate CVs
    pub mean: f64,
-   pub is_used: bool,


     //   //tsl: Disable strategy - if a groups stops being problematic, disable all the tracepoints for that
@@ -75,7 +77,7 @@ impl Group {

         /// tsl: add enabled tracepoints for the groups
     // pub fn update_enabled_tracepoints(&mut self, decisions: &Vec<(TracepointID, Option<RequestType>)>) {
-        
+
     //     for decision in decisions {
     //         self.enabled_tps.push(&decision);
     //     }
@@ -95,6 +97,7 @@ impl Group {
         for (_, group) in hash_map.iter_mut() {
             group.calculate_variance();
             group.calculate_mean();
+            //add group.find_unique_value_pairs
             if group.variance == 0.0 {
                 zeros += 1;
             }
@@ -145,10 +148,9 @@ impl Group {
             traces: vec![path],
             variance: 0.0,
             mean: 0.0,
-            is_used: false,
             // enabled_tps: Vec<(TracepointID, Option<RequestType>)> = Vec::new(),
             //cv: 0.0,
-          //  key_value_pairs: TraceNode::get_key_values(),
+            key_value_pairs: HashMap::<String, Vec<Value>>::new(),
         }
     }

@@ -157,7 +159,6 @@ impl Group {
     pub fn used(&mut self) {
         self.traces = Vec::new();
         self.variance = 0.0;
-        self.is_used = true;
     }

     /// Returns all edges sorted by variance.
@@ -183,21 +184,14 @@ impl Group {
                 None => break,
             };
         }
-        // tsl : edge variances are here; so maybe; sum them up and divide them by the total variance
         let mut result = edge_variances
             .into_iter()
             .collect::<Vec<(EdgeIndex, f64)>>();
         result.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
-         //tsl: let's see
-        let sum: f64 = result.iter().map(|a| a.1).sum();
-        println!("*New Metric: hash {:?}, reqtype {:?}, total var {:?}, edge_total: {:?}", self.hash, self.request_type, self.variance, sum);
         result.iter().map(|a| a.0).collect()
-
-       
     }

     fn add_trace(&mut self, path: &CriticalPath) {
-        println!("**** A trace {:?} added to group{:?}",path.g.base_id, self.hash);
         self.traces.push(path.clone());
         let mut cur_node = path.start_node;
         let mut prev_node = None;
@@ -228,29 +222,64 @@ impl Group {
     // tsl: calculate mean of the group
     fn calculate_mean(&mut self) {
         // change below variance to mean
-        self.mean = mean(self.traces.iter().map(|x| x.duration.as_nanos()));
+        self.mean = mean(self.traces.iter().map(|x| x.duration.as_secs()));
         if self.mean != 0.0 {
             println!("Set mean of {:?} - {} to {}", self.request_type, self.hash, self.mean);
         }
     }
     fn calculate_variance(&mut self) {
-        println!(
-            "Duration of each trace: {:?}",
-                self.traces.iter().
-                map(|x| x.duration.as_nanos())
-                .collect::<Vec<_>>()
-        );
-        self.variance = variance(self.traces.iter().map(|x| x.duration.as_nanos()));
+        self.variance = variance(self.traces.iter().map(|x| x.duration.as_secs()));
         if self.variance != 0.0 {
             println!("Set variance of {:?} - {} to {}", self.request_type, self.hash, self.variance);
         }
     }
-}
+   pub fn find_unique_pairs(&mut self) {
+        //append tracepoint names to key-value pairs
+        let mut pair_map = HashMap::new();
+        let mut vec_trace = HashSet::new();
+        for nodes in self.g.node_indices(){
+            for (key, value) in self.g[nodes].key_value_pair.clone()
+            {
+                if value.len()!=0 {
+                let mut new_key : String = key.to_owned();
+                let mut trace_key1 = &self.g[nodes].tracepoint_id.id.to_string().clone();
+                let mut trace_key: &str =&self.g[nodes].tracepoint_id.id.to_string().as_str().to_owned();
+                if !vec_trace.contains(&trace_key1.clone())
+                {
+                    let mut trace_string = trace_key1.clone();
+                vec_trace.insert(trace_string);
+                new_key.push_str(trace_key);
+                   // println!("Inside function: {:?}, {:?}", new_key, value);
+                pair_map.insert(new_key, value);
+                }
+                }
+               // println!("Inside function: {:?},{:?}",key.clone(),value.clone());
+            }
+        //println!("{:?}",self.g[nodes].key_value_pair);
+
+       }
+        self.key_value_pairs = pair_map;
+        //println!("{:?}", self.key_value_pairs);
+    }
+
+   pub fn pearson_calc(&mut self) {
+    let mut values_vec = Vec::<Value>::new();
+    let mut durations_vec = Vec::<Duration>::new();
+    for edges in self.g.edge_indices() {
+        for durations in self.g[edges].duration.clone()
+        {
+            let duration_array : [f64;1]=[durations.secs.clone() as f64];
+            for (key, value) in self.key_value_pairs {
+               let correlated_val =correlation(value, mem::size_of_val(&value),&duration_array,mem::size_of_val(&durations),1);
+            }
+         //   durations_vec.push(durations);
+        }
+    }
+    }
+

-// # key value = hostname = client | server  ---> Append trace_id 0000> 
-// 1231-123_hostname = "client" , 1233331-123_hostname = "client"

-// 2222-123_hostname = "client"
+}

 impl Path for Group {
     fn get_hash(&self) -> &str {
@@ -308,7 +337,6 @@ impl GroupManager {
             match self.groups.get_mut(path.hash()) {
                 Some(v) => v.add_trace(&path),
                 None => {
-                    println!("**** A trace {:?} created a group{:?}",path.g.base_id, path.hash().to_string());
                     self.groups
                         .insert(path.hash().to_string(), Group::new(path.clone()));
                 }
@@ -318,6 +346,7 @@ impl GroupManager {
         for h in updated_groups {
             self.groups.get_mut(h).unwrap().calculate_variance();
             self.groups.get_mut(h).unwrap().calculate_mean();
+            //add key value pairs with appended tracepoint names?
         }
     }

@@ -334,19 +363,15 @@ impl GroupManager {
     }
     /// tsl: Return groups filtered based on coefficient of variance
     pub fn problem_groups_cv(&self, cv_threshold: f64) -> Vec<&Group> {
-        // println!("Groups in CV Analaysis: {}", groups);
         let mut sorted_groups: Vec<&Group> = self
             .groups
             .values()
-            .filter(|&g| g.is_used != true) // TODO: what happens to used groups?
             .filter(|&g| g.variance != 0.0)
             .filter(|&g| (g.variance.sqrt()/g.mean) > cv_threshold) // tsl: g.CV > Threshold
             .filter(|&g| g.traces.len() > 3)
             .collect();
         sorted_groups.sort_by(|a, b| b.variance.partial_cmp(&a.variance).unwrap());
-        // println!("\n**Groups sorted in CV Analaysis: {}", sorted_groups);
         sorted_groups
-
     }

     /// tsl: Return groups filtered based on mean distribution -- consistently slow groups
@@ -389,13 +414,11 @@ impl Display for Group {
     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
         write!(
             f,
-            "Group<{} {:?} traces, mean: {:?}, var: {:?}, cv:{:?}, hash: {:?}>",
+            "Group<{} {:?} traces, mean: {:?}, var: {:?}>",
             self.traces.len(),
             self.request_type,
-            self.mean/1000000.0,
+            self.mean,
             self.variance,
-            self.variance.sqrt()/self.mean,
-            self.hash
         )
     }
 }
@@ -414,3 +437,4 @@ impl Display for GroupManager {
         Ok(())
     }
 }
+
diff --git a/src/trace.rs b/src/trace.rs
index cb116e6..59ceef5 100644
--- a/src/trace.rs
+++ b/src/trace.rs
@@ -1,6 +1,9 @@
 //! General trace implementation
 //!

+extern crate rgsl;
+use rgsl::statistics::correlation;
+
 use std::fmt;
 use std::fmt::Debug;
 use std::fmt::Display;
@@ -43,6 +46,7 @@ pub struct Trace {
     pub duration: Duration,
     /// used by osprofiler to find keys to delete from redis
     pub keys: Vec<String>,
+    pub key_value_pairs: HashMap<String, Value>,
 }

 impl Trace {
@@ -55,6 +59,7 @@ impl Trace {
             request_type: RequestType::Unknown,
             duration: Duration::new(0, 0),
             keys: Vec::new(),
+            key_value_pairs: HashMap<String, Value>,
         }
     }

@@ -296,7 +301,12 @@ impl TraceNode {
                 vec_thread_name.push(value);
             }
         }
-
+        map.insert("agent".to_string(), vec_agent);
+        map.insert("hrt".to_string(), vec_hrt);
+        map.insert("process ID".to_string(), vec_proc_id);
+        map.insert("process name".to_string(), vec_proc_name);
+        map.insert("thread ID".to_string(), vec_thread_id);
+        map.insert("threa name".to_string(), vec_thread_name);
         map.insert("lock_queue".to_string(), vec_value);
         map.insert("host".to_string(), vec_host);

@@ -346,7 +356,7 @@ lazy_static! {
 /// We do some tricks to keep tracepoint ids as `usize`s so it uses less memory than strings.
 #[derive(Hash, Clone, Copy, Eq, PartialEq)]
 pub struct TracepointID {
-    id: usize,
+    pub id: usize,
 }

 impl TracepointID {
@@ -425,3 +435,4 @@ impl<'de> Deserialize<'de> for TracepointID {
         d.deserialize_str(TracepointIDVisitor)
     }
 }
+
diff --git a/traceid b/traceid
deleted file mode 100644
index 28ad4d5..0000000
--- a/traceid
+++ /dev/null
@@ -1 +0,0 @@
-7e77bc42-83c6-42b5-92b2-f5f4a4ef2fea
                                               